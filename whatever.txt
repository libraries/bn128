// Extended euclidean algorithm to find modular inverses for integers.
// The return value INV_X satisfies: (X * INV_X) % N = 1
inline uint256 _invmod(const uint256 &x, const uint256 &n) {
  uint256 u = x;
  uint256 v = n;
  uint256 b = 1;
  uint256 c = 0;

  while (u != 1 && v != 1) {
    while (!(u & 1)) {
      u >>= 1;
      if (!(b & 1)) {
        b >>= 1;
      } else {
        b += n;
        b >>= 1;
      }
    }
    while (!(v & 1)) {
      v >>= 1;
      if (!(c & 1)) {
        c >>= 1;
      } else {
        c += n;
        c >>= 1;
      }
    }
    if (u >= v) {
      u -= v;
      b = _submod(b, c, n);
    } else {
      v -= u;
      c = _submod(c, b, n);
    }
  }

  if (u == 1) {
    return b;
  } else {
    return c;
  }
}


// Montgomery reduction, also known as REDC.
// REDC(T)=T*R' mod N(N>1)ï¼Œ
uint256 REDC(uint256 T) {
  uint512 t = intx::uint512{T};
  uint512 n = intx::uint512{FIELE_MODULUS_PRIME};

  uint512 m = T * n % ;

  // uint256 a = T;
  // for (int i = 0; i < 256; i++) {
  //   if ((a & 1) == 1) {
  //     a += FIELD_MODULUS;
  //   }
  //   a = a >> 1;
  // }
  // if (a >= FIELD_MODULUS) {
  //   a -= FIELD_MODULUS;
  // }
  // return a;
}


void fq2_mul(const uint256 x[2], const uint256 y[2], uint256 r[2]) {
  // uint256 aa = fq_mul(x[0], y[0]);
  // uint256 bb = fq_mul(x[1], y[1]);
  // uint256 non_residue =
  //     mont_encode(intx::from_string<uint256>("0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd46"));
  // uint256 c0 = fq_add(fq_mul(bb, non_residue), aa);
  // uint256 c1 = fq_sub(fq_sub(fq_mul(fq_add(x[0], x[1]), fq_add(y[0], y[1])), aa), bb);

  uint256 a = fq_sub(fq_mul(x[0], y[0]), fq_mul(x[1], y[1]));
  uint256 b = fq_add(fq_mul(x[0], y[1]), fq_mul(x[1], y[0]));
  r[0] = a;
  r[1] = b;
}
