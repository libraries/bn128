// Extended euclidean algorithm to find modular inverses for integers.
// The return value INV_X satisfies: (X * INV_X) % N = 1
inline uint256 _invmod(const uint256 &x, const uint256 &n) {
  uint256 u = x;
  uint256 v = n;
  uint256 b = 1;
  uint256 c = 0;

  while (u != 1 && v != 1) {
    while (!(u & 1)) {
      u >>= 1;
      if (!(b & 1)) {
        b >>= 1;
      } else {
        b += n;
        b >>= 1;
      }
    }
    while (!(v & 1)) {
      v >>= 1;
      if (!(c & 1)) {
        c >>= 1;
      } else {
        c += n;
        c >>= 1;
      }
    }
    if (u >= v) {
      u -= v;
      b = _submod(b, c, n);
    } else {
      v -= u;
      c = _submod(c, b, n);
    }
  }

  if (u == 1) {
    return b;
  } else {
    return c;
  }
}
